# 前后端双向IPC通信

JadeView 提供了强大的前后端双向 IPC（进程间通信）机制，允许前端 JavaScript 代码与后端 C/C++ 代码进行高效、安全的双向数据交换。本页面将详细介绍 JadeView 的 IPC 通信原理、使用方法和最佳实践。

## 什么是 IPC 通信

IPC（Inter-Process Communication，进程间通信）是指不同进程之间进行数据交换的机制。在 JadeView 中，IPC 通信主要用于：

- 前端 JavaScript 代码向后端发送指令或请求数据
- 后端 C/C++ 代码向前端推送事件或数据更新
- 实现前后端之间的双向数据绑定

## JadeView IPC 通信的技术原理

JadeView 的 IPC 通信基于以下技术原理：

### 1. 基于消息队列的通信机制

JadeView 使用高效的消息队列实现前后端通信：

- 前端通过 `window.jade.ipcSend()` 方法发送消息
- 消息被序列化后通过底层通道发送到后端
- 后端通过 `jade_on()` 注册消息处理器接收消息
- 后端通过 `send_ipc_message()` 向前端发送消息
- 前端通过 `window.jade.ipcMain()` 注册消息处理器接收消息

### 2. 跨语言序列化与反序列化

为了实现跨语言通信，JadeView 使用 JSON 作为消息序列化格式：

- 前端 JavaScript 直接使用 JSON.stringify() 和 JSON.parse() 进行序列化和反序列化
- 后端 C/C++ 使用内置的 JSON 解析库处理消息
- 支持基本数据类型、对象、数组等复杂数据结构



## 前端到后端的 IPC 通信

### 1. 前端发送消息

在前端 JavaScript 中，可以通过 `window.jade.ipcSend()` 方法向后端发送消息：

有关 Web SDK 的详细信息，请查看 [Web SDK 文档](/web-sdk)。

```javascript
// 发送简单消息
window.jade.ipcSend('message-name', JSON.stringify({ key: 'value' }));

// 发送复杂数据
const data = {
  user: {
    id: 1,
    name: 'John Doe'
  },
  action: 'update_user',
  timestamp: Date.now()
};

window.jade.ipcSend('user-update', JSON.stringify(data));
```

### 2. 后端接收消息

在后端 C/C++ 代码中，使用 `jade_on()` 函数注册消息处理器：

有关 C API 的详细信息，请查看 [C API 文档](/guides/reference/c-api)。

```c
#include "jadeview.h"

// 消息处理器回调函数
int message_handler(uint32_t window_id, const char* event_type, const char* event_data) {
    printf("收到消息：type=%s, data=%s\n", event_type, event_data);
    
    // 解析 JSON 数据
    // 这里可以使用你喜欢的 JSON 解析库
    
    return 0; // 允许操作
}

// 在 app-ready 事件中注册消息处理器
int app_ready_callback(int success, const char* reason) {
    if (success == 1 && reason && strcmp(reason, "success") == 0) {
        // 注册消息处理器
        jade_on("message-name", message_handler);
        jade_on("user-update", message_handler);
    }
    return 0;
}
```

## 后端到前端的 IPC 通信

### 1. 后端发送消息

在后端 C/C++ 代码中，使用 `send_ipc_message()` 函数向前端发送消息：

有关 C API 的详细信息，请查看 [C API 文档](/guides/reference/c-api)。

```c
#include "jadeview.h"

// 发送简单消息
void send_message_to_frontend(uint32_t window_id) {
    // 消息内容
    const char* message_data = "{\"status\": \"success\", \"message\": \"操作成功\"}";
    
    // 发送消息到指定窗口
    int result = send_ipc_message(window_id, "backend-message", message_data);
    
    if (result == 1) {
        printf("消息发送成功\n");
    } else {
        printf("消息发送失败\n");
    }
}

// 发送广播消息给所有窗口
void broadcast_message() {
    const char* message_data = "{\"type\": \"system\", \"data\": {\"time\": 1234567890}}";
    
    // 窗口 ID 为 0 表示广播给所有窗口
    int result = send_ipc_message(0, "system-update", message_data);
    
    if (result == 1) {
        printf("广播消息发送成功\n");
    } else {
        printf("广播消息发送失败\n");
    }
}
```

### 2. 前端接收消息

在前端 JavaScript 中，使用 `window.jade.ipcMain()` 方法注册消息处理器：

有关 Web SDK 的详细信息，请查看 [Web SDK 文档](/web-sdk)。

```javascript
// 接收简单消息
window.jade.ipcMain('backend-message', (content) => {
    const data = JSON.parse(content);
    console.log('收到后端消息:', data);
    
    if (data.status === 'success') {
        alert('操作成功：' + data.message);
    }
});

// 接收系统更新消息
window.jade.ipcMain('system-update', (content) => {
    const data = JSON.parse(content);
    console.log('系统更新:', data);
    
    // 更新页面数据
    document.getElementById('system-time').textContent = new Date(data.data.time).toLocaleString();
});
```

## 完整的 IPC 通信示例

### 前端 JavaScript 代码

```javascript
// 发送消息到后端
function sendMessage(message) {
  const data = {
    message: message,
    timestamp: Date.now()
  };
  
  window.jade.ipcSend('frontend-message', JSON.stringify(data));
}

// 接收后端消息
window.jade.ipcMain('backend-message', (content) => {
  const data = JSON.parse(content);
  console.log('收到后端消息:', data);
  // 处理后端消息，例如更新 UI
});

// 监听页面加载完成
window.addEventListener('load', () => {
  // 发送页面加载完成消息
  window.jade.ipcSend('page-loaded', JSON.stringify({ status: 'ready' }));
});

// 示例：发送一条测试消息
sendMessage('Hello from frontend!');
```

### 后端代码

```c
#include "jadeview.h"
#include <stdio.h>
#include <string.h>
#include <time.h>

// 前端消息处理器
int frontend_message_handler(uint32_t window_id, const char* event_type, const char* event_data) {
    printf("收到前端消息：type=%s, data=%s\n", event_type, event_data);
    
    // 构造回复消息
    char reply_data[512];
    time_t now = time(NULL);
    
    snprintf(reply_data, sizeof(reply_data), 
             "{\"message\": \"收到消息：%s\", \"timestamp\": %ld}", 
             event_data, (long)now);
    
    // 发送回复给前端
    send_ipc_message(window_id, "backend-message", reply_data);
    
    return 0;
}

// 页面加载完成处理器
int page_loaded_handler(uint32_t window_id, const char* event_type, const char* event_data) {
    printf("页面加载完成，窗口 ID：%u\n", window_id);
    
    // 发送欢迎消息
    char welcome_msg[256];
    time_t now = time(NULL);
    
    snprintf(welcome_msg, sizeof(welcome_msg), 
             "{\"message\": \"欢迎使用 JadeView IPC 通信示例\", \"timestamp\": %ld}", 
             (long)now);
    
    send_ipc_message(window_id, "backend-message", welcome_msg);
    
    return 0;
}

// app-ready 事件处理器
int app_ready_callback(int success, const char* reason) {
    if (success == 1 && reason && strcmp(reason, "success") == 0) {
        printf("JadeView 准备就绪\n");
        
        // 注册消息处理器
        jade_on("frontend-message", frontend_message_handler);
        jade_on("page-loaded", page_loaded_handler);
        
        // 创建 WebView 窗口
        WebViewWindowOptions options = {
            .title = "IPC 通信示例",
            .width = 800,
            .height = 600,
            .resizable = 1,
            .remove_titlebar = 0
        };
        
        WebViewSettings settings = {
            .autoplay = 0,
            .background_throttling = 0,
            .disable_right_click = 0
        };
        
        uint32_t window_id = create_webview_window(
            "http://localhost:8080", // 本地服务器 URL
            0,
            &options,
            &settings
        );
        
        if (window_id == 0) {
            printf("窗口创建失败\n");
        }
    }
    return 0;
}

int main() {
    // 初始化 DLL
    int result = JadeView_init(1, NULL, NULL);
    
    if (result == 0) {
        printf("DLL 初始化失败\n");
        return 1;
    }
    
    // 注册 app-ready 事件
    jade_on("app-ready", app_ready_callback);
    
    // 运行消息循环
    run_message_loop();
    
    // 清理资源
    cleanup_all_windows();
    
    return 0;
}
```

## IPC 通信的最佳实践

### 1. 消息命名规范

- 使用清晰、描述性的消息名称
- 采用小写字母和连字符分隔（kebab-case）
- 避免使用过于通用的名称
- 为不同模块使用前缀，如 `user-`、`system-`、`ui-`

### 2. 数据结构设计

- 保持消息数据结构简单清晰
- 使用一致的数据格式
- 包含必要的元数据（如 timestamp）
- 为复杂数据提供清晰的类型定义

### 3. 错误处理

- 实现完善的错误处理机制
- 向前端返回明确的错误代码和消息
- 记录详细的错误日志
- 避免崩溃

### 4. 性能优化

- 避免频繁发送大量数据
- 对大数据进行分页或压缩
- 合理使用广播消息
- 及时清理不再使用的消息处理器

### 5. 安全性考虑

- 验证所有输入数据
- 对敏感数据进行加密
- 限制消息大小
- 实现消息速率限制

## IPC 通信的高级特性

### 1. 支持的消息类型

JadeView 支持多种类型的 IPC 消息：

- **单向消息**：发送后不需要回复
- **请求-响应模式**：发送消息并等待回复
- **广播消息**：发送给所有窗口
- **定向消息**：发送给特定窗口

### 2. 消息优先级

JadeView 支持消息优先级：

- **高优先级**：系统事件、紧急通知
- **中优先级**：用户交互、数据更新
- **低优先级**：日志、统计数据

### 3. 消息队列管理

JadeView 提供了完善的消息队列管理：

- 自动处理消息积压
- 支持消息超时机制
- 提供消息队列状态查询

## 与其他框架的 IPC 通信对比

| 框架 | IPC 通信机制 | 性能 | 安全性 | 易用性 |
|------|--------------|------|--------|--------|
| JadeView | 基于消息队列的 JSON 通信 | 高 | 高 | 简单易用 |
| Electron | IPC 模块 | 中 | 中 | 中等复杂度 |
| NW.js | WebSocket + IPC | 中 | 中 | 较复杂 |
| CEF | 自定义消息传递 | 高 | 中 | 复杂 |

## 总结

JadeView 的前后端双向 IPC 通信机制提供了高效、安全、易用的跨语言通信解决方案。通过简单的 API，开发者可以轻松实现前后端之间的数据交换和事件驱动开发。

- **高效**：基于消息队列的设计，确保低延迟和高吞吐量
- **安全**：严格的消息验证和加密机制
- **易用**：简洁的 API 设计，降低开发复杂度
- **灵活**：支持多种通信模式和消息类型

JadeView 的 IPC 通信机制是构建现代化桌面应用的重要基础，为开发者提供了强大的前后端协作能力。